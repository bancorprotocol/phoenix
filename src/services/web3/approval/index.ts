import { Token } from 'services/observables/tokens';
import { web3, writeWeb3 } from 'services/web3';
import BigNumber from 'bignumber.js';
import { bancorNetwork$ } from 'services/observables/contracts';
import { take } from 'rxjs/operators';
import { user$ } from 'services/observables/user';
import {
  NULL_APPROVAL_CONTRACTS,
  UNLIMITED_WEI,
} from 'services/web3/approval/constants';
import { ethToken } from 'services/web3/config';
import { expandToken } from 'utils/formulas';
import { Token__factory } from '../abis/types';

interface GetApprovalReturn {
  allowanceWei: string;
  isApprovalRequired: boolean;
}

const getApproval = async (
  token: string,
  user: string,
  spender: string,
  amountWei: string
): Promise<GetApprovalReturn> => {
  if (token === ethToken)
    return { allowanceWei: '', isApprovalRequired: false };

  const tokenContract = Token__factory.connect(token, web3.provider);
  const allowanceWei = (
    await tokenContract.allowance(user, spender)
  ).toString();

  const isApprovalRequired = new BigNumber(amountWei).gt(
    new BigNumber(allowanceWei)
  );
  return { allowanceWei, isApprovalRequired };
};

const setApproval = async (
  token: string,
  user: string,
  spender: string,
  amountWei?: string,
  resolveImmediately?: boolean
): Promise<string> => {
  const isEth = token === ethToken;
  if (isEth) return '';

  const tokenContract = Token__factory.connect(token, writeWeb3.signer);

  const amountFinal = amountWei ? amountWei : UNLIMITED_WEI;

  const isNullApprovalContract = NULL_APPROVAL_CONTRACTS.includes(token);

  if (isNullApprovalContract) {
    const { allowanceWei } = await getApproval(
      token,
      user,
      spender,
      amountFinal
    );
    if (Number(allowanceWei) !== 0) {
      const tx = await tokenContract.approve(spender, '0');
      await tx.wait();
    }
  }

  try {
    const tx = await tokenContract.approve(spender, amountFinal);
    if (!resolveImmediately) await tx.wait();
    return tx.hash;
  } catch (e: any) {
    const isTxDenied = e.message.toLowerCase().includes('denied');

    if (!isTxDenied) {
      // TODO send this error with failed contract to Sentry or GTM
      NULL_APPROVAL_CONTRACTS.push(token);
      console.error(
        'Approval had failed, next try forcing a zero approval in case required',
        e.message
      );
    }

    throw e;
  }
};

export const getNetworkContractApproval = async (
  token: Token,
  amount: string,
  contract?: string
): Promise<boolean> => {
  // If contract argument not provided, default to bancor
  const spender = contract
    ? contract
    : await bancorNetwork$.pipe(take(1)).toPromise();

  const USER = await user$.pipe(take(1)).toPromise();

  const amountWei = expandToken(amount, token.decimals);

  const { isApprovalRequired } = await getApproval(
    token.address,
    USER,
    spender,
    amountWei
  );

  return isApprovalRequired;
};

export const setNetworkContractApproval = async (
  token: Token,
  amount?: string,
  contract?: string,
  resolveImmediately?: boolean
) => {
  const BANCOR_NETWORK = await bancorNetwork$.pipe(take(1)).toPromise();
  const USER = await user$.pipe(take(1)).toPromise();
  const amountWei = amount ? expandToken(amount, token.decimals) : undefined;
  return await setApproval(
    token.address,
    USER,
    contract ? contract : BANCOR_NETWORK,
    amountWei,
    resolveImmediately
  );
};
